using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace ExtremeRoles.UnitTest.MockGenerator
{
    [Generator]
    public class MockGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var assemblyProvider = context.CompilationProvider.SelectMany((compilation, _) =>
                compilation.SourceModule.ReferencedAssemblySymbols
                    .Where(q => q.Name != "AmongUsLibExporter" && q.Kind == SymbolKind.Assembly));

            context.RegisterSourceOutput(assemblyProvider, (spc, assemblySymbol) =>
            {
                if (assemblySymbol == null) return;

                var allNamespaces = new List<INamespaceSymbol>();
                CollectNamespaces(assemblySymbol.GlobalNamespace, allNamespaces);

                foreach (var ns in allNamespaces)
                {
                    foreach (var typeSymbol in ns.GetTypeMembers())
                    {
                        if (typeSymbol.TypeKind == TypeKind.Class)
                        {
                            var (interfaceSource, className) = GenerateInterfaceSource(typeSymbol);
                            if (!string.IsNullOrEmpty(interfaceSource))
                            {
                                // ファイル名が重複しないようにアセンブリ名も含める
                                spc.AddSource($"{assemblySymbol.Name}_{ns.ToDisplayString().Replace('.', '_')}_{className}.g.cs", SourceText.From(interfaceSource, Encoding.UTF8));
                            }
                        }
                    }
                }
            });
        }

        private void CollectNamespaces(INamespaceSymbol namespaceSymbol, List<INamespaceSymbol> allNamespaces)
        {
            allNamespaces.Add(namespaceSymbol);
            foreach (var childNs in namespaceSymbol.GetNamespaceMembers())
            {
                CollectNamespaces(childNs, allNamespaces);
            }
        }

        private (string, string) GenerateInterfaceSource(INamedTypeSymbol classSymbol)
        {
            var className = classSymbol.Name;
            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            var sb = new StringBuilder();
            sb.AppendLine($"// Auto-generated by ExtremeRoles.UnitTest.MockGenerator for class {namespaceName}.{className}");
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine($"    public interface {className}"); // 元のクラス名と同じ名前でインターフェースを作成
            sb.AppendLine("    {");

            // プロパティの生成
            foreach (var member in classSymbol.GetMembers())
            {
                if (member is IPropertySymbol property)
                {
                    if (property.DeclaredAccessibility == Accessibility.Public ||
                        property.DeclaredAccessibility == Accessibility.Internal ||
                        property.DeclaredAccessibility == Accessibility.ProtectedOrInternal ||
                        property.DeclaredAccessibility == Accessibility.Protected)
                    {
                        sb.AppendLine($"        public {property.Type.ToDisplayString()} {property.Name} {{ get; set; }}");
                    }
                }
                else if (member is IFieldSymbol field && field.AssociatedSymbol == null)
                {
                     if (field.DeclaredAccessibility == Accessibility.Public ||
                         field.DeclaredAccessibility == Accessibility.Internal ||
                         field.DeclaredAccessibility == Accessibility.ProtectedOrInternal ||
                         field.DeclaredAccessibility == Accessibility.Protected)
                    {
                        sb.AppendLine($"        public {field.Type.ToDisplayString()} {field.Name} {{ get; set; }}");
                    }
                }
            }

            // メソッドの生成
            foreach (var member in classSymbol.GetMembers().OfType<IMethodSymbol>())
            {
                if (member.MethodKind == MethodKind.Ordinary &&
                    (member.DeclaredAccessibility == Accessibility.Public ||
                     member.DeclaredAccessibility == Accessibility.Internal ||
                     member.DeclaredAccessibility == Accessibility.ProtectedOrInternal ||
                     member.DeclaredAccessibility == Accessibility.Protected))
                {
                    var parameters = string.Join(", ", member.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));
                    var returnType = member.ReturnsVoid ? "void" : member.ReturnType.ToDisplayString();
                    sb.AppendLine($"        public {returnType} {member.Name}({parameters});");
                }
            }

            // 静的メンバーの生成
            foreach (var member in classSymbol.GetMembers())
            {
                if (member.IsStatic)
                {
                    if (member is IMethodSymbol staticMethod && staticMethod.MethodKind == MethodKind.Ordinary &&
                        (staticMethod.DeclaredAccessibility == Accessibility.Public ||
                         staticMethod.DeclaredAccessibility == Accessibility.Internal ||
                         staticMethod.DeclaredAccessibility == Accessibility.ProtectedOrInternal ||
                         staticMethod.DeclaredAccessibility == Accessibility.Protected))
                    {
                        var mockMethodName = $"Mock_{staticMethod.Name}";
                        var parameters = staticMethod.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}").ToList();
                        var parameterNames = string.Join(", ", staticMethod.Parameters.Select(p => p.Name));
                        var returnType = staticMethod.ReturnsVoid ? "void" : staticMethod.ReturnType.ToDisplayString();

                        string actionOrFuncType;
                        if (staticMethod.ReturnsVoid)
                        {
                            actionOrFuncType = parameters.Any() ? $"System.Action<{string.Join(", ", staticMethod.Parameters.Select(p => p.Type.ToDisplayString()))}>" : "System.Action";
                        }
                        else
                        {
                            var typeArgs = staticMethod.Parameters.Select(p => p.Type.ToDisplayString()).ToList();
                            typeArgs.Add(returnType);
                            actionOrFuncType = $"System.Func<{string.Join(", ", typeArgs)}>";
                        }

                        sb.AppendLine($"        public static {actionOrFuncType} {mockMethodName}Mock {{ get; set; }}");

                        sb.Append($"        public static {returnType} {mockMethodName}(");
                        sb.Append(string.Join(", ", parameters));
                        sb.AppendLine(")");
                        sb.AppendLine("        {");
                        if (staticMethod.ReturnsVoid)
                        {
                            sb.AppendLine($"            {mockMethodName}Mock?.Invoke({parameterNames});");
                        }
                        else
                        {
                            sb.AppendLine($"            return {mockMethodName}Mock != null ? {mockMethodName}Mock.Invoke({parameterNames}) : default({returnType});");
                        }
                        sb.AppendLine("        }");
                    }
                }
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return (sb.ToString(), className);
        }
    }
}
