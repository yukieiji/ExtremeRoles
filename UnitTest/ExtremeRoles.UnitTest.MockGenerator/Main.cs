using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Mono.Cecil;
// Mono.Cecil.Cil も必要に応じて残しておく
// using Mono.Cecil.Cil;

namespace ExtremeRoles.UnitTest.MockGenerator;

public static class Generator
{
	// 変更点: assemblyPath を string[] で受け取るように変更
	public static void GenerateInterfaces(string[] assemblyPaths, string outputDirectory)
	{
		if (!Directory.Exists(outputDirectory))
		{
			Directory.CreateDirectory(outputDirectory);
		}

		StringBuilder sb = new StringBuilder();
		sb.AppendLine("// This file was auto-generated by InteropInterfaceGenerator.");
		sb.AppendLine("// DO NOT MODIFY THIS FILE MANUALLY.");
		sb.AppendLine();
		sb.AppendLine($"namespace GeneratedInteropInterfaces");
		sb.AppendLine("{");

		foreach (string assemblyPath in assemblyPaths)
		{
			if (!File.Exists(assemblyPath))
			{
				Console.WriteLine($"Warning: Assembly not found at {assemblyPath}. Skipping.");
				continue;
			}

			Console.WriteLine($"Loading assembly: {assemblyPath}");
			AssemblyDefinition assembly;
			try
			{
				// 依存関係の解決が必要な場合、DefaultAssemblyResolver を設定することも考慮
				// ReaderParameters rp = new ReaderParameters { AssemblyResolver = new DefaultAssemblyResolver() };
				// ((DefaultAssemblyResolver)rp.AssemblyResolver).AddSearchDirectory(Path.GetDirectoryName(assemblyPath));
				// assembly = AssemblyDefinition.ReadAssembly(assemblyPath, rp);

				assembly = AssemblyDefinition.ReadAssembly(assemblyPath);
			}
			catch (BadImageFormatException ex)
			{
				Console.WriteLine($"Warning: Could not load {assemblyPath} as a valid .NET assembly (might be native DLL). Skipping. Error: {ex.Message}");
				continue;
			}
			catch (Exception ex)
			{
				Console.WriteLine($"Error loading assembly {assemblyPath}: {ex.Message}. Skipping.");
				continue;
			}

			Console.WriteLine($"Generating interfaces for assembly: {assembly.FullName}");

			foreach (TypeDefinition type in assembly.MainModule.Types)
			{
				// COMインターフェースを識別するロジックをより堅牢に
				// System.Runtime.InteropServices.ComImportAttribute や GuidAttribute を持つインターフェース
				// あるいは他のCOM相互運用に関連する特定のパターン
				bool isComInterface = type.IsInterface &&
									  (type.CustomAttributes.Any(attr => attr.AttributeType.FullName == typeof(System.Runtime.InteropServices.ComImportAttribute).FullName) ||
									   type.CustomAttributes.Any(attr => attr.AttributeType.FullName == typeof(System.Runtime.InteropServices.GuidAttribute).FullName));

				if (isComInterface)
				{
					Console.WriteLine($"Found COM interface: {type.FullName} in {assembly.Name.Name}.");
					GenerateInterfaceCode(sb, type);
				}
				else if (type.IsInterface && type.IsPublic && !type.FullName.StartsWith("System."))
				{
					// COMインターフェースではないが、一般的なパブリックインターフェースもモックしたい場合
					// この条件はプロジェクトの要件に合わせて調整してください
					// Console.WriteLine($"Found public interface: {type.FullName} in {assembly.Name.Name}.");
					// GenerateInterfaceCode(sb, type);
				}
			}
		}

		sb.AppendLine("}");

		string outputPath = Path.Combine(outputDirectory, "GeneratedInteropInterfaces.cs");
		File.WriteAllText(outputPath, sb.ToString());
		Console.WriteLine($"Generated interfaces written to: {outputPath}");
	}

	// GenerateInterfaceCode と GetFriendlyTypeName は前回のコードと同じでOKです。
	// ただし、COM固有の型や属性の扱いは、実際のDLLに合わせて調整が必要になります。
	private static void GenerateInterfaceCode(StringBuilder sb, TypeDefinition type)
	{
		// ... 前回の GenerateInterfaceCode メソッドの内容 ...
		sb.AppendLine($"    public interface I{type.Name.Replace("I", "")}Mockable"); // 先頭の'I'を除去し、Mockableサフィックスを追加
		sb.AppendLine("    {");

		// メソッドの生成
		foreach (MethodDefinition method in type.Methods.Where(m => m.IsPublic))
		{
			// PreserveSigAttribute の有無などを考慮し、戻り値の型を調整する例
			string returnType = GetFriendlyTypeName(method.ReturnType);
			if (method.CustomAttributes.Any(attr => attr.AttributeType.FullName == typeof(System.Runtime.InteropServices.PreserveSigAttribute).FullName))
			{
				// PreserveSigがある場合、HRESULTはそのままInt32として扱う
				// しかし、多くのCOMメソッドはHRESULTを内部で処理し、C#側ではvoidや本来の戻り値型で公開される
				// ここはCOMの変換規則をよく理解して調整が必要
				if (returnType == "int" && type.FullName.Contains(".HRESULT")) // 簡易的な判定
				{
					// HRESULTをInt32として残すか、voidに変換するかなど
				}
			}

			string parameters = string.Join(", ", method.Parameters.Select(p =>
			{
				string paramType = GetFriendlyTypeName(p.ParameterType);
				string modifiers = "";
				if (p.IsOut) modifiers += "out ";
				if (p.IsReturnValue) modifiers += "ref "; // これは通常使われない
														  // 他にも MarshalAsAttribute など、COM固有の属性を考慮する必要がある

				return $"{modifiers}{paramType} {p.Name}";
			}));
			sb.AppendLine($"        {returnType} {method.Name}({parameters});");
		}

		// プロパティの生成
		foreach (PropertyDefinition property in type.Properties.Where(p => p.GetMethod?.IsPublic == true || p.SetMethod?.IsPublic == true))
		{
			string propertyType = GetFriendlyTypeName(property.PropertyType);
			sb.Append($"        {propertyType} {property.Name} {{ ");
			if (property.GetMethod?.IsPublic == true) sb.Append("get; ");
			if (property.SetMethod?.IsPublic == true) sb.Append("set; ");
			sb.AppendLine("}");
		}

		// イベントの生成はCOMの場合非常に特殊なため、ここではコメントアウトしておくのが無難です。
		// 実際のCOMイベントは IConnectionPointContainer / IConnectionPoint などを通じて行われるため、
		// 単純な .NET イベントとはモックの仕方が異なります。
		// foreach (EventDefinition @event in type.Events)
		// {
		//     sb.AppendLine($"        event {GetFriendlyTypeName(@event.EventType)} {@event.Name};");
		// }

		sb.AppendLine("    }");
		sb.AppendLine();
	}

	private static string GetFriendlyTypeName(TypeReference typeRef)
	{
		// ... 前回の GetFriendlyTypeName メソッドの内容 ...
		// 特に System.Runtime.InteropServices.ComTypes.IEnumXXXX など、
		// COM相互運用でよく使われる型への対応を強化すると良いでしょう。

		// 例: System.Object を object に変換
		if (typeRef.FullName == "System.Object") return "object";
		// 例: System.String を string に変換
		if (typeRef.FullName == "System.String") return "string";
		// 例: System.Int32 を int に変換
		if (typeRef.FullName == "System.Int32") return "int";
		// 例: System.Boolean を bool に変換
		if (typeRef.FullName == "System.Boolean") return "bool";
		// その他の組み込み型も同様に追加

		// COM Interopでよく使われる型を特定の名前空間で扱う例
		if (typeRef.Namespace == "System.Runtime.InteropServices")
		{
			// Guid はそのまま Guid
			if (typeRef.Name == "Guid") return "System.Guid";
			// IntPtr もそのまま IntPtr
			if (typeRef.Name == "IntPtr") return "System.IntPtr";
		}

		// 完全な名前空間を含めるか、using ディレクティブを使うかを検討
		if (!string.IsNullOrEmpty(typeRef.Namespace) && typeRef.Namespace != "System")
		{
			return $"{typeRef.Namespace}.{typeRef.Name}";
		}
		return typeRef.Name;
	}
}

public static class Program
{
	static void Main(string[] args)
	{
		if (args.Length < 2)
		{
			Console.WriteLine("Usage: InteropInterfaceGenerator <outputDirectory> <assemblyPath1> [assemblyPath2] ...");
			return;
		}

		string outputDirectory = args[0];
		string[] assemblyPaths = args.Skip(1).ToArray();

		Generator.GenerateInterfaces(assemblyPaths, outputDirectory);
	}
}